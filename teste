@Service
public class JourneyService {

    private static final Logger logger = Logger.getLogger(JourneyService.class.getName());

    private static final String JOURNEY_NAO_ENCONTRADO = "Journey informado não foi encontrado.";
    private static final String LISTA_DE_JOURNEYS_VAZIA = "Lista de Journeys vazia.";

    private final DemandaReservaService demandaReservaService;
    private final DemandaReservaRepository demandaReservaRepository;
    private final ConjuntoComponenteMapper conjuntoComponenteMapper;
    private final RestTemplate restTemplate;

    @Value("${journey_authorization}")
    private String journeyAuthorization;

    @Value("${journey_url}")
    private String journeyUrl;

    @Value("${cost_center_url}")
    private String costCenterUrl;

    public JourneyService(
            DemandaReservaService demandaReservaService,
            DemandaReservaRepository demandaReservaRepository,
            ConjuntoComponenteMapper conjuntoComponenteMapper,
            RestTemplate restTemplate
    ) {
        this.demandaReservaService = demandaReservaService;
        this.demandaReservaRepository = demandaReservaRepository;
        this.conjuntoComponenteMapper = conjuntoComponenteMapper;
        this.restTemplate = restTemplate;
    }

    public JourneyDTO fetchJourneysInApiServiceNow(String id) {
        demandaReservaService.checkIfJourneyExists(id);

        ResponseEntity<List<JourneyClientDTO>> response;

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));
        headers.set("User-Agent", "Mozilla/5.0");
        headers.set("Authorization", journeyAuthorization.startsWith("Basic") ? journeyAuthorization : "Basic " + journeyAuthorization);

        HttpEntity<String> entity = new HttpEntity<>(headers);

        try {
            logger.info("Fetching journey from external API...");
            response = restTemplate.exchange(
                    journeyUrl + "/" + id,
                    HttpMethod.GET,
                    entity,
                    new ParameterizedTypeReference<List<JourneyClientDTO>>() {
                    }
            );
        } catch (HttpClientErrorException e) {
            logger.warning("API returned an error: " + e.getMessage());
            throw new ResourceNotFoundException(LISTA_DE_JOURNEYS_VAZIA);
        }

        List<JourneyClientDTO> journeys = Optional.ofNullable(response.getBody())
                .orElseThrow(() -> new ResourceNotFoundException(LISTA_DE_JOURNEYS_VAZIA));

        JourneyClientDTO journey = journeys.stream()
                .filter(j -> id.equals(j.getNumeroDemanda()))
                .findFirst()
                .orElseThrow(() -> new ResourceNotFoundException(JOURNEY_NAO_ENCONTRADO + " idJourney: " + id));

        String key = journey.getFase() + "|" + journey.getSubfase();

        if ("Close|Cancelled".equals(key)) {
            throw new JourneyConflictException("Journey foi cancelado. Informe um id válido!");
        }

        return JourneyDTO.builder()
                .id(journey.getNumeroDemanda())
                .cc(journey.getCentroDeCusto())
                .cpf(journey.getCpf())
                .fase(journey.getFase())
                .subfase(journey.getSubfase())
                .build();
    }

    public JourneyTechLeadDTO fetchJourneysTechLead(String idJourney) {
        DemandaReserva demandaReserva = demandaReservaRepository.findByIdJourney(idJourney)
                .orElseThrow(() -> new ResourceNotFoundException("Journey not found"));

        CostCenterTechLeadDTO costCenterTechLeadDTO = fetchCostCenter(demandaReserva.getCc());

        List<ArchetypeTechLeadDTO> archetypes = demandaReserva.getArquetipos().stream()
                .map(conjuntoComponenteMapper::convertToArchetypeDTO)
                .collect(Collectors.toList());

        return JourneyTechLeadDTO.builder()
                .id(demandaReserva.getIdJourney())
                .enviroment(demandaReserva.getEnvironment())
                .cpf(demandaReserva.getCpf())
                .costcenter(costCenterTechLeadDTO)
                .archetypes(archetypes)
                .build();
    }

    private CostCenterTechLeadDTO fetchCostCenter(String ccSigla) {
        try {
            CostCenterTechLeadDTO[] costCenters = restTemplate.getForObject(costCenterUrl, CostCenterTechLeadDTO[].class);

            if (costCenters != null) {
                return Arrays.stream(costCenters)
                        .filter(costCenter -> ccSigla.equals(costCenter.getSigla()))
                        .findFirst()
                        .orElseThrow(() -> new ResourceNotFoundException("Cost center not found for sigla: " + ccSigla));
            }

            throw new ResourceNotFoundException("Cost center data is empty for sigla: " + ccSigla);
        } catch (RestClientException e) {
            throw new ResourceNotFoundException("Failed to fetch cost center data", e);
        }
    }
}
