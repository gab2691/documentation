private void copyDirectoryFromClasspath(String resourcePath, Path targetPath) throws IOException {
    ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
    Resource[] resources = resolver.getResources("classpath*:" + resourcePath + "/**");

    for (Resource resource : resources) {
        if (resource.isReadable()) {
            // Extrai o caminho dentro do JAR
            String pathInJar = resource.getURL().getPath();

            // Remove prefixos como "file:", "jar:" e "BOOT-INF/classes!"
            if (pathInJar.contains("!")) {
                pathInJar = pathInJar.substring(pathInJar.indexOf("!") + 1);
            }

            // Remove "/BOOT-INF/classes" se estiver presente
            pathInJar = pathInJar.replace("/BOOT-INF/classes", "");

            // Garante que o caminho comece com "/"
            if (!pathInJar.startsWith("/")) {
                pathInJar = "/" + pathInJar;
            }

            // Calcula o caminho relativo após o resourcePath
            int startIndex = pathInJar.indexOf("/" + resourcePath) + resourcePath.length() + 1;
            String relativePath = pathInJar.substring(startIndex);

            Path targetFile = targetPath.resolve(relativePath);

            if (resource.getURL().toString().endsWith("/")) {
                // É um diretório; cria se não existir
                Files.createDirectories(targetFile);
            } else {
                // É um arquivo; copia
                Files.createDirectories(targetFile.getParent());
                try (InputStream is = resource.getInputStream()) {
                    Files.copy(is, targetFile, StandardCopyOption.REPLACE_EXISTING);
                }
            }

            // Log para verificar o caminho de destino
            logger.info("Copiado recurso para: {}", targetFile);
        }
    }
}
