import java.util.*;
import java.util.function.ToIntFunction;

public class BaseAlgorithms {

    public static void main(String[] args) {
        TreeNode root = new TreeNode(7, new TreeNode(4, new TreeNode(3), new TreeNode(5)), new TreeNode(15, null, null));
        TreeNode deleteBST = new TreeNode(4, new TreeNode(2, new TreeNode(1), new TreeNode(3)), new TreeNode(6, new TreeNode(5), new TreeNode(7)));

        System.out.println("Before Deletion :");
        TreeNode.printFormattedTree(deleteBST);
        deleteBST(deleteBST, 6);
        System.out.println("After Deletion :");
        TreeNode.printFormattedTree(deleteBST);

        System.out.println("Before insertion :");
        TreeNode.printFormattedTree(root);
        System.out.println("After insertion :");
        TreeNode.printFormattedTree(insertBST(root, 16));

        dfsInOrder(root);
        bfsTree(root);
        System.out.println("binarySearchTree: " + searchBST(new TreeNode(4, new TreeNode(2, new TreeNode(1), new TreeNode(3)), new TreeNode(7, null, null)), 2).val);
        System.out.println("binarySearch: " + binarySearch(new int[]{1, 2, 3, 4, 1, 3, 7, 5, 6, 9}, 5));
        System.out.println("twoPointers: " + Arrays.toString(twoPointers(new int[]{-1, 2, 3, 4, 7, 9}, 7)));
        System.out.println("kadane: " + Arrays.toString(kadane(new int[]{2, 1, -4, 3, 4})));
        System.out.println("fixedSlidingWindow: " + fixedSlidingWindow(new int[]{1, 2, 3, 4, 1, 3, 7, 3, 5}, 3));
        System.out.println("variableSlidingWindow: " + variableSlidingWindow(new int[]{1, 2, 3, 4, 1, 3, 7, 5}, 8));
    }

    // this is the BFS algorithm
    static void bfsTree(TreeNode root) {
        Deque<TreeNode> queue = new ArrayDeque<>();
        if (root != null)
            queue.add(root);

        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode currentNode = queue.removeFirst();
                if (currentNode.left != null)
                    queue.add(currentNode.left);
                if (currentNode.right != null)
                    queue.add(currentNode.right);
            }
        }
    }

    // this is DFS inOrder
    static void dfsInOrder(TreeNode root) {
        if (root == null)
            return;

        dfsInOrder(root.left);
        System.out.println(root.val);
        dfsInOrder(root.right);
    }

    // this algorithm is for deletion of a node in a BST
    static TreeNode deleteBST(TreeNode root, int val) {
        if (root == null)
            return null;

        if (val > root.val)
            root.right = deleteBST(root.right, val);
        else if (val < root.val)
            root.left = deleteBST(root.left, val);
        else {
            if (root.right == null)
                return root.left;
            else if (root.left == null)
                return root.right;
            else {
                root.val = minValue(root.right).val;
                root.right = deleteBST(root.right, root.val);
            }
        }
        return root;
    }

    static TreeNode minValue(TreeNode root) {
        TreeNode currentNode = root;
        while (currentNode != null && currentNode.left != null)
            currentNode = currentNode.left;
        return currentNode;
    }

    // Esse algorithm inseri novos nodes em uma binary search tree
    static TreeNode insertBST(TreeNode root, int val) {
        if (root == null)
            return new TreeNode(val);

        if (val > root.val)
            root.right = insertBST(root.right, val);
        else if (val < root.val)
            root.left = insertBST(root.left, val);

        return root;
    }

    // binary search tree
    // esse algorithm devolve o node que estamos procurando em um BST
    static TreeNode searchBST(TreeNode root, int target) {
        if (root == null)
            return null;

        if (target > root.val)
            return searchBST(root.right, target);
        else if (target < root.val)
            return searchBST(root.left, target);
        else return root;
    }

    // binary search algoritimo, muito eficiente mas o array tem que estar ordenado
    static int binarySearch(int[] nums, int target) {
        Arrays.sort(nums);
        int l = 0, r = nums.length - 1;
        while (l <= r) {
            int mid = (r + l) / 2;
            if (target > nums[mid])
                l = mid + 1;
            else if (target < nums[mid])
                r = mid - 1;
            else return r;
        }
        return -1;
    }

    // Two pointers esse algoritmo serve para varios tipos de problemas que temos que navegar pelo array de forma eficiente,
    // nessse exemplo devolvemos os indices que somados são iguais ao targert.
    static int[] twoPointers(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while (l < r) {
            int sum = nums[r] + nums[l];
            if (target > sum)
                l++;
            else if (target < sum)
                r--;
            else return new int[]{l, r};
        }
        return null;
    }

    // Sliding window com tamanho variaval,
    // Esse algoritimo devolve o tamanho minimo de uma janela que seja maior ou igual a algum valor recebido,
    static int variableSlidingWindow(int[] nums, int target) {
        int l = 0;
        int currentSum = 0;
        int length = Integer.MAX_VALUE;
        for (int r = 0; r < nums.length; r++) {
            currentSum += nums[r];
            while (currentSum >= target) {
                currentSum -= nums[l];
                length = Math.min(r - l + 1, length);
                l++;
            }
        }
        return length == Integer.MAX_VALUE ? 0 : length;
    }


    // Sliding window com janela fiza, esse algoritimo mantem uma janela fixa dentro do array pode ser a sua soma ou identificar se dentro da janela temos algum numero repetido
    // Esse por exemplo indica se tem um numero repetido dentro da janela que é o valor de K
    static boolean fixedSlidingWindow(int[] nums, int k) {
        Set<Integer> set = new HashSet<>();
        int l = 0;
        for (int r = 0; r < nums.length; r++) {
            if (r - l + 1 > k) {
                set.remove(nums[l]);
                l++;
            }
            if (set.contains(nums[r])) {
                return true;
            }
            set.add(nums[r]);
        }
        return false;
    }


    // Kadane algoritimo ele se enquadra em algumas categorias como, greedy two pointer e slding window
    // aqui estamos devolvendo o maior subSet de numeros em um array, ou seja, dentro do array temos que indentificar a maior soma dentro do array e denvolver seus indices
    static int[] kadane(int[] nums) {
        int maxSum = nums[0], currentSum = 0;
        int finalL = 0, finalR = 0, l = 0;

        for (int r = 0; r < nums.length; r++) {
            if (currentSum < 0) {
                currentSum = 0;
                l = r;
            }
            currentSum += nums[r];
            if (currentSum > maxSum) {
                maxSum = currentSum;
                finalL = l;
                finalR = r;
            }
        }
        return new int[]{finalL, finalR};
    }

}
